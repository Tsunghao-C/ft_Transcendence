input {
  beats {
    port => 5044
    ssl_enabled => true
    ssl_certificate => "/usr/share/logstash/config/certs/logstash.crt"
    ssl_key => "/usr/share/logstash/config/certs/logstash.key"
    ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
    # ssl_verify_mode => "force_peer"
    ssl_client_authentication => "required"
  }
}

filter {
  # Web Traffic Processing
  if [fields][type] == "nginx" {
    # Common processing for all nginx logs
    mutate {
      add_field => { "type" => "%{[fields][type]}" }
    }

    # Access logs specific processing
    if [fields][source] == "access" {
      # Still need json parser to parse each key in the message into a field
      json {
        source => "message"
      }
      date {
        match => [ "time_local", "dd/MMM/yyyy:HH:mm:ss Z" ]
        target => "@timestamp"
      }
      mutate {
        convert => {
          "status" => "integer"
          "body_bytes_sent" => "integer"
          "request_time" => "float"
          "upstream_response_time" => "float"
        }
      }
      # Add response type classification
      mutate {
        add_field => { "response_type" => "%{[status]}" }
      }
      # Classify HTTP status codes
      if [status] =~ /^4\d\d/ {
        mutate { add_tag => ["client_error"] }
      } else if [status] =~ /^5\d\d/ {
        mutate { add_tag => ["server_error"] }
      }
      # Performance monitoring
      if [request_time] > 1 {
        mutate { add_tag => ["slow_request"] }
      }
      # Security pattern detection
      if [request] =~ /(?i)(SELECT|UNION|DROP|DELETE|INSERT|UPDATE)/ {
        mutate { add_tag => ["potential_sql_injection"] }
      }
      if [request] =~ /(?i)<script>|javascript:/ {
        mutate { add_tag => ["potential_xss"] }
      }
      geoip {
        source => "remote_addr"
        target => "geo"
      }
      useragent {
        source => "http_user_agent"
        target => "user_agent"
      }
      if [modsec_transaction_id] != "" {
        mutate {
          add_tag => ["waf_event"]
        }
      }
      # Cleanup raw message after parsing
      mutate { remove_field => ["message"] }
      # Drop event if missing critical fields
      if ![status] or ![remote_addr] {
        drop { }
      }
    }

    # Error logs specific processing
    else if [fields][source] == "error" {
      grok {
        patterns_dir => ["/etc/logstash/patterns"]
        match => { 
          "message" => [
            # ModSecurity initialization
            "%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME} \[%{LOGLEVEL:log_level}\] %{POSINT:process_id}#%{POSINT:thread_id}: ModSecurity-nginx v%{DATA:modsec_version} \(rules loaded %{GREEDYDATA:rules_info}\)",
            # Keep-alive logs
            "%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME} \[%{LOGLEVEL:log_level}\] %{POSINT:process_id}#%{POSINT:thread_id}: \*%{NUMBER:connection_id} client %{IP:client_ip} closed keepalive connection",
            # ModSecurity violation
            "%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME} \[%{LOGLEVEL:log_level}\] %{POSINT:process_id}#%{POSINT:thread_id}: \*%{NUMBER:connection_id} \[client %{IP:client_ip}\] ModSecurity: (?<modsec_message>Access denied with code %{NUMBER:response_code:int}) \(phase %{NUMBER:modsec_phase}\)\.(?<rule_info>.*)\[file \"(?<rule_file>[^\"]+)\"\] \[line \"(?<rule_line>[^\"]+)\"\] \[id \"(?<rule_id>[^\"]+)\"\](.*)\[msg \"(?<rule_msg>[^\"]+)\"\] \[data \"(?<rule_data>[^\"]+)\"\] \[severity \"(?<severity>[^\"]+)\"\](?<additional_info>.*)(, client: %{IP:client_ip_duplicate}, server: %{HOSTNAME:server_name}, request: \"%{DATA:request}\", host: \"%{DATA:host}\")",
            # Default pattern for other errors
            "%{YEAR}/%{MONTHNUM}/%{MONTHDAY} %{TIME} \[%{LOGLEVEL:log_level}\] %{POSINT:process_id}#%{POSINT:thread_id}: \*%{NUMBER:connection_id} %{GREEDYDATA:error_message}"
          ]
        }
      }
      if [log_level] {
        mutate {
          add_field => { "log_severity" => "%{[log_level]}" }
        }
        if [log_level] == "error" {
          mutate { add_tag => ["error_level"] }
        } else if [log_level] == "warn" {
          mutate { add_tag => ["warn_level"] }
        } else if [log_level] == "notice" {
          mutate { add_tag => ["notice_level"] }
        } else if [log_level] == "info" {
          mutate { add_tag => ["info_level"] }
        }
      }
      # Skip noise like processing keepalive messages
      if [log_level] == "info" and [error_message] =~ "closed keepalive connection" {
        drop { }
      }
      date {
        match => ["timestamp", "yyyy/MM/dd HH:mm:ss" ]
        target => "@timestamp"
      }
      if [modsec_message] {
        mutate {
          add_tag => ["modsecurity_violation"]
          add_field => {
            "attack_type" => "unknown"
          }
        }
        if [rule_msg] =~ /XSS/ {
          mutate {
            update => {"attack_type" => "xss" }
            add_tag => ["attack_xss"]
          }
        } else if [rule_msg] =~ /SQL Injection/ {
          mutate {
            update => { "attack_type" => "sql_injection" }
            add_tag => ["attack_sqli"]
          }
        } else if [rule_msg] =~ /Command Injection/ {
          mutate {
            update => { "attack_type" => "command_injection" }
            add_tag => ["attack_rce"]
          }
        }
      }
      mutate {
        remove_field => ["client_ip_duplicate"]
      }
    }
  }
  # # WAF Log Processing (ModSecurity)
  # else if [fields][type] == "waf" {
  #   mutate {
  #     add_field => { "type" => "%{[fields][type]}" }
  #   }
  #   # Audit log processing
  #   if [fields][source] == "audit" {
  #     # Parse ModSecurity audit log sections
  #     grok {
  #       match => { "message" => "(?m)^---(%{NOTSPACE:transaction_id})---(%{WORD:section_letter})--\n%{GREEDYDATA:section_content}" }
  #       tag_on_failure => ["_grokparsefailure", "waf_audit_parse_failure"]
  #     }
      
  #     # Process different sections based on their letter
  #     if [section_letter] == "A" {
  #       # Transaction metadata
  #       grok {
  #         match => { "section_content" => "\[%{HTTPDATE:timestamp}\] %{NUMBER:unique_id:float} %{IP:client_ip} %{NUMBER:client_port:int} %{IP:server_ip} %{NUMBER:server_port:int}" }
  #         tag_on_failure => ["_section_A_parse_failure"]
  #       }
  #       date {
  #         match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  #         target => "@timestamp"
  #       }
  #     }
  #     else if [section_letter] == "B" {
  #       # Request headers
  #       grok {
  #         match => { "section_content" => "(?m)%{WORD:http_method} %{NOTSPACE:uri} HTTP/%{NUMBER:http_version}\n%{GREEDYDATA:request_headers}" }
  #         tag_on_failure => ["_section_B_parse_failure"]
  #       }
  #       kv {
  #         source => "request_headers"
  #         field_split => "\n"
  #         value_split => ": "
  #         target => "parsed_request_headers"
  #       }
  #     }
  #     else if [section_letter] == "F" {
  #       # Response headers
  #       grok {
  #         match => { "section_content" => "HTTP/%{NUMBER:response_http_version} %{NUMBER:response_status:int}[^\\n]*\n%{GREEDYDATA:response_headers}" }
  #         tag_on_failure => ["_section_F_parse_failure"]
  #       }
  #       kv {
  #         source => "response_headers"
  #         field_split => "\n"
  #         value_split => ": "
  #         target => "parsed_response_headers"
  #       }
  #     }
  #     else if [section_letter] == "H" {
  #       # Audit log trailer
  #       kv {
  #         source => "section_content"
  #         field_split => "\n"
  #         value_split => ": "
  #         target => "audit_details"
  #       }
  #     }

  #     # Add severity based on response status
  #     if [response_status] =~ /^4\d\d/ {
  #       mutate {
  #         add_field => { "severity" => "warning" }
  #       }
  #     } else if [response_status] =~ /^5\d\d/ {
  #       mutate {
  #         add_field => { "severity" => "error" }
  #       }
  #     }

  #     # Add enrichments
  #     if [client_ip] {
  #       geoip {
  #         source => "client_ip"
  #         target => "geo"
  #       }
  #     }

  #     # Add attack type detection
  #     if [uri] =~ /<script>/ {
  #       mutate {
  #         add_field => { "attack_type" => "xss" }
  #       }
  #     }
  #   }

  #   else if [fields][source] == "debug" {
  #     grok {
  #       match => { "message" => "\[%{NUMBER:timestamp:float}\] \[%{DATA:uri}\] \[%{NUMBER:session_id}\] %{GREEDYDATA:debug_message}" }
  #       tag_on_failure => ["_debug_parse_failure"]
  #     }
  #     # Add rule matching information
  #     if [debug_message] =~ /Rule (\d+) returned/ {
  #       grok {
  #         match => {
  #           "debug_message" => "Rule (?<rule_id>\d+) returned (?<rule_return>\d+)"
  #         }
  #       }
  #     }
  #   }
  # }
  ## Adding more filters for future data source
  # # Application Logs Processing
  # if [fields][type] == "application" {
  #   if [fields][service] == "auth" {
  #     grok {
  #       match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:message}" }
  #     }
  #     # Add authentication-specific processing
  #   }

  #   if [fields][service] == "game" {
  #     grok {
  #       match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:message}" }
  #     }
  #     # Add game-specific processing
  #   }
  # }
}

output {
  # Route logs to different indices based on category
  if [fields][type] == "nginx" {
    if [fields][source] == "access" {
      elasticsearch {
        hosts => ["https://elasticsearch:9200"]
        user => "${ELASTIC_USER}"
        password => "${ELASTIC_PASSWORD}"
        ssl_verification_mode => "full"
        ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
        index => "nginx-access"
      }
    }
    else if [fields][source] == "error" {
      elasticsearch {
        hosts => ["https://elasticsearch:9200"]
        user => "${ELASTIC_USER}"
        password => "${ELASTIC_PASSWORD}"
        ssl_verification_mode => "full"
        ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
        index => "nginx-error"
      }
    }
  }
  # else if [fields][type] == "waf" {
  #   if [fields][source] == "audit" {
  #     elasticsearch {
  #       hosts => ["https://elasticsearch:9200"]
  #       user => "${ELASTIC_USER}"
  #       password => "${ELASTIC_PASSWORD}"
  #       ssl_verification_mode => "full"
  #       ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
  #       index => "waf-audit"
  #     }
  #   }
  #   else if [fields][source] == "debug" {
  #     elasticsearch {
  #       hosts => ["https://elasticsearch:9200"]
  #       user => "${ELASTIC_USER}"
  #       password => "${ELASTIC_PASSWORD}"
  #       ssl_verification_mode => "full"
  #       ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
  #       index => "waf-debug"
  #     }
  #   }
  # }
  # # Added later when they are ready
  # else if [category] == "security" {
  #   elasticsearch {
  #     hosts => ["https://elasticsearch:9200"]
        # user => "${ELASTIC_USER}"
        # password => "${ELASTIC_PASSWORD}"
  #     index => "security-logs"
  #   }
  # }
  # else if [category] == "gameplay" {
  #   elasticsearch {
  #     hosts => ["https://elasticsearch:9200"]
        # user => "${ELASTIC_USER}"
        # password => "${ELASTIC_PASSWORD}"
  #     index => "game-logs"
  #   }
  # }
  else {
    elasticsearch {
      hosts => ["https://elasticsearch:9200"]
      user => "${ELASTIC_USER}"
      password => "${ELASTIC_PASSWORD}"
      ssl_verification_mode => "full"
      ssl_certificate_authorities => ["/usr/share/logstash/config/certs/ca.crt"]
      index => "other-logs"
    }
  }
  # Debug output
  stdout { codec => rubydebug}
}